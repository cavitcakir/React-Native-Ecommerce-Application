{"version":3,"sources":["SwitchRouter.js"],"names":["defaultActionCreators","routeConfigs","config","order","Object","keys","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","Error","map","n","join","childRouters","forEach","routeName","screen","router","getParamsForRoute","params","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","resetChildRoute","initialParams","undefined","childRouter","childAction","NavigationActions","init","getStateForAction","key","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","index","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","keyToAdd","routes","filter","k","push","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","isTransitioning","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","SwitchActions","JUMP_TO","findIndex","i","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","max","length","routeKey","didNavigate","find","childId","childState","newChildState","childStateUpdate","SET_PARAMS","lastRoute","isActionBackOrPop","StackActions","POP","POP_TO_TOP","sendActionToInactiveChildren","preserveFocus","getComponentForState","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;AAEA,MAAMA,qBAAqB,GAAG,OAAO,EAAP,CAA9B;;eAEe,CAACC,YAAD,EAAeC,MAAM,GAAG,EAAxB,KAA+B;AAC5C;AACA,uCAAuBD,YAAvB;AAEA,QAAME,KAAK,GAAGD,MAAM,CAACC,KAAP,IAAgBC,MAAM,CAACC,IAAP,CAAYJ,YAAZ,CAA9B;AAEA,QAAMK,uBAAuB,GAC3BJ,MAAM,CAACI,uBAAP,IAAkCN,qBADpC;AAGA,QAAMO,kBAAkB,GAAGL,MAAM,CAACK,kBAAlC;AACA,QAAMC,gBAAgB,GAAGN,MAAM,CAACM,gBAAP,IAA2BL,KAAK,CAAC,CAAD,CAAzD;AACA,QAAMM,YAAY,GAAGP,MAAM,CAACO,YAAP,IAAuB,MAA5C;AACA,QAAMC,WAAW,GAAGR,MAAM,CAACS,cAAP,CAAsB,aAAtB,IAChBT,MAAM,CAACQ,WADS,GAEhB,IAFJ;AAIA,QAAME,iBAAiB,GAAGT,KAAK,CAACU,OAAN,CAAcL,gBAAd,CAA1B;;AACA,MAAII,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,UAAM,IAAIE,KAAJ,CACJ,oCAA6BN,gBAA7B,qCACsBL,KAAK,CAACY,GAAN,CAAUC,CAAC,gBAAQA,CAAR,OAAX,EAAyBC,IAAzB,CAA8B,IAA9B,CADtB,CADI,CAAN;AAID;;AAED,QAAMC,YAAY,GAAG,EAArB;AACAf,EAAAA,KAAK,CAACgB,OAAN,CAAcC,SAAS,IAAI;AACzBF,IAAAA,YAAY,CAACE,SAAD,CAAZ,GAA0B,IAA1B;AACA,UAAMC,MAAM,GAAG,oCAAsBpB,YAAtB,EAAoCmB,SAApC,CAAf;;AACA,QAAIC,MAAM,CAACC,MAAX,EAAmB;AACjBJ,MAAAA,YAAY,CAACE,SAAD,CAAZ,GAA0BC,MAAM,CAACC,MAAjC;AACD;AACF,GAND;;AAQA,WAASC,iBAAT,CAA2BH,SAA3B,EAAsCI,MAAtC,EAA8C;AAC5C,QAAIC,WAAW,GAAGxB,YAAY,CAACmB,SAAD,CAA9B;;AACA,QAAIK,WAAW,IAAIA,WAAW,CAACD,MAA/B,EAAuC;AACrC,+BAAYC,WAAW,CAACD,MAAxB,MAAmCA,MAAnC;AACD,KAFD,MAEO;AACL,aAAOA,MAAP;AACD;AACF;;AAED,QAAM;AACJE,IAAAA,wBADI;AAEJC,IAAAA;AAFI,MAGF,iCAAiBT,YAAjB,EAA+BjB,YAA/B,EAA6CC,MAA7C,CAHJ;;AAKA,WAAS0B,eAAT,CAAyBR,SAAzB,EAAoC;AAClC,QAAIS,aAAa,GACfT,SAAS,KAAKZ,gBAAd,GAAiCD,kBAAjC,GAAsDuB,SADxD,CADkC,CAGlC;AACA;AACA;;AACA,QAAIN,MAAM,GAAGD,iBAAiB,CAACH,SAAD,EAAYS,aAAZ,CAA9B;AACA,UAAME,WAAW,GAAGb,YAAY,CAACE,SAAD,CAAhC;;AACA,QAAIW,WAAJ,EAAiB;AACf,YAAMC,WAAW,GAAGC,iBAAiB,CAACC,IAAlB,EAApB;AACA,+BACKH,WAAW,CAACI,iBAAZ,CAA8BH,WAA9B,CADL;AAEEI,QAAAA,GAAG,EAAEhB,SAFP;AAGEA,QAAAA,SAHF;AAIEI,QAAAA;AAJF;AAMD;;AACD,WAAO;AACLY,MAAAA,GAAG,EAAEhB,SADA;AAELA,MAAAA,SAFK;AAGLI,MAAAA;AAHK,KAAP;AAKD;;AAED,WAASa,YAAT,CAAsBC,MAAtB,EAA8BC,SAA9B,EAAyCC,iBAAzC,EAA4D;AAC1D,aAASC,sBAAT,CAAgCF,SAAhC,EAA2CG,SAA3C,EAAsD;AACpD,UACEjC,YAAY,KAAK,SAAjB,IACC8B,SAAS,IAAIG,SAAb,IAA0BA,SAAS,CAACC,KAAV,KAAoBJ,SAAS,CAACI,KAF3D,EAGE;AACA,eAAOD,SAAP;AACD;;AACD,UAAIE,mBAAmB,GAAGL,SAAS,GAAGA,SAAS,CAACM,eAAb,GAA+B,EAAlE;;AACA,UAAIP,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACc,QAAtC,EAAgD;AAC9CH,QAAAA,mBAAmB,GAAG,CAAC,GAAGA,mBAAJ,CAAtB,CAD8C,CACE;;AAChD,cAAMI,QAAQ,GAAGN,SAAS,CAACO,MAAV,CAAiBP,SAAS,CAACC,KAA3B,EAAkCP,GAAnD;AACAQ,QAAAA,mBAAmB,GAAGA,mBAAmB,CAACM,MAApB,CAA2BC,CAAC,IAAIA,CAAC,KAAKH,QAAtC,CAAtB,CAH8C,CAGyB;;AACvEJ,QAAAA,mBAAmB,CAACQ,IAApB,CAAyBJ,QAAzB;AACD,OALD,MAKO,IAAIV,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACoB,IAAtC,EAA4C;AACjDT,QAAAA,mBAAmB,GAAG,CAAC,GAAGA,mBAAJ,CAAtB,CADiD,CACD;;AAChDA,QAAAA,mBAAmB,CAACU,GAApB;AACD;;AACD,+BACKZ,SADL;AAEEG,QAAAA,eAAe,EAAED;AAFnB;AAID;;AAED,QAAIF,SAAS,GAAGF,iBAAhB;;AACA,QACED,SAAS,IACTC,iBADA,IAEAD,SAAS,CAACI,KAAV,KAAoBH,iBAAiB,CAACG,KAFtC,IAGAjC,WAJF,EAKE;AACA,YAAM6C,aAAa,GAAGhB,SAAS,CAACU,MAAV,CAAiBV,SAAS,CAACI,KAA3B,EAAkCvB,SAAxD;AACA,YAAMoC,UAAU,GAAG,CAAC,GAAGhB,iBAAiB,CAACS,MAAtB,CAAnB;AACAO,MAAAA,UAAU,CAACjB,SAAS,CAACI,KAAX,CAAV,GAA8Bf,eAAe,CAAC2B,aAAD,CAA7C;AACAb,MAAAA,SAAS,qBACJF,iBADI;AAEPS,QAAAA,MAAM,EAAEO;AAFD,QAAT;AAID;;AACD,WAAOf,sBAAsB,CAACF,SAAD,EAAYG,SAAZ,CAA7B;AACD;;AAED,WAASe,eAAT,GAA2B;AACzB,UAAMR,MAAM,GAAG9C,KAAK,CAACY,GAAN,CAAUa,eAAV,CAAf;AACA,UAAM8B,YAAY,GAAG;AACnBT,MAAAA,MADmB;AAEnBN,MAAAA,KAAK,EAAE/B,iBAFY;AAGnB+C,MAAAA,eAAe,EAAE;AAHE,KAArB;;AAKA,QAAIlD,YAAY,KAAK,SAArB,EAAgC;AAC9B,YAAMmD,UAAU,GAAGX,MAAM,CAACrC,iBAAD,CAAN,CAA0BwB,GAA7C;AACAsB,MAAAA,YAAY,CAAC,iBAAD,CAAZ,GAAkC,CAACE,UAAD,CAAlC;AACD;;AACD,WAAOF,YAAP;AACD;;AAED,SAAO;AACLxC,IAAAA,YADK;;AAGL2C,IAAAA,iBAAiB,CAACC,KAAD,EAAQC,QAAR,EAAkB;AACjC,aAAOzD,uBAAuB,CAACwD,KAAD,EAAQC,QAAR,CAA9B;AACD,KALI;;AAOL5B,IAAAA,iBAAiB,CAACG,MAAD,EAAS0B,UAAT,EAAqB;AACpC,UAAIzB,SAAS,GAAGyB,UAAU,qBAAQA,UAAR,IAAuBA,UAAjD;AACA,UAAIC,KAAK,GAAGD,UAAU,IAAIP,eAAe,EAAzC;AACA,UAAIS,gBAAgB,GAAGD,KAAK,CAACtB,KAA7B;;AAEA,UAAIL,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACkC,IAAtC,EAA4C;AAC1C;AACA;AACA;AACA;AACA,cAAM;AAAE3C,UAAAA;AAAF,YAAac,MAAnB;;AACA,YAAId,MAAJ,EAAY;AACVyC,UAAAA,KAAK,CAAChB,MAAN,GAAegB,KAAK,CAAChB,MAAN,CAAalC,GAAb,CAAiB+C,KAAK,sBAChCA,KADgC;AAEnCtC,YAAAA,MAAM,oBACDsC,KAAK,CAACtC,MADL,MAEDA,MAFC,MAGAsC,KAAK,CAAC1C,SAAN,KAAoBZ,gBAApB,GACAD,kBADA,GAEA,IALA;AAF6B,YAAtB,CAAf;AAUD;AACF;;AAED,UACE+B,MAAM,CAACQ,IAAP,KAAgBsB,aAAa,CAACC,OAA9B,KACC/B,MAAM,CAACF,GAAP,IAAc,IAAd,IAAsBE,MAAM,CAACF,GAAP,KAAe6B,KAAK,CAAC7B,GAD5C,CADF,EAGE;AACA,cAAM;AAAEZ,UAAAA;AAAF,YAAac,MAAnB;AACA,cAAMK,KAAK,GAAGsB,KAAK,CAAChB,MAAN,CAAaqB,SAAb,CACZR,KAAK,IAAIA,KAAK,CAAC1C,SAAN,KAAoBkB,MAAM,CAAClB,SADxB,CAAd;;AAIA,YAAIuB,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,gBAAM,IAAI7B,KAAJ,CACJ,mCAA4BwB,MAAM,CAAClB,SAAnC,8CAAgFkB,MAAM,CAACF,GAAvF,sCACqB6B,KAAK,CAAChB,MAAN,CAChBlC,GADgB,CACZ+C,KAAK,eAAQA,KAAK,CAAC1C,SAAd,MADO,EAEhBH,IAFgB,CAEX,GAFW,CADrB,CADI,CAAN;AAMD;;AAED,eAAOoB,YAAY,CAACC,MAAD,EAASC,SAAT,oBACd0B,KADc;AAEjBhB,UAAAA,MAAM,EAAEzB,MAAM,GACVyC,KAAK,CAAChB,MAAN,CAAalC,GAAb,CAAiB,CAAC+C,KAAD,EAAQS,CAAR,KACfA,CAAC,KAAK5B,KAAN,qBAESmB,KAFT;AAGMtC,YAAAA,MAAM,oBACDsC,KAAK,CAACtC,MADL,MAEDA,MAFC;AAHZ,eAQIsC,KATN,CADU,GAYVG,KAAK,CAAChB,MAdO;AAejBN,UAAAA;AAfiB,WAAnB;AAiBD,OA5DmC,CA8DpC;;;AACA,YAAM6B,oBAAoB,GAAGP,KAAK,CAAChB,MAAN,CAAagB,KAAK,CAACtB,KAAnB,CAA7B;AACA,YAAM8B,iBAAiB,GAAGvD,YAAY,CAACf,KAAK,CAAC8D,KAAK,CAACtB,KAAP,CAAN,CAAtC;;AACA,UAAI8B,iBAAJ,EAAuB;AACrB,cAAMC,gBAAgB,GAAGD,iBAAiB,CAACtC,iBAAlB,CACvBG,MADuB,EAEvBkC,oBAFuB,CAAzB;;AAIA,YAAI,CAACE,gBAAD,IAAqBV,UAAzB,EAAqC;AACnC,iBAAO,IAAP;AACD;;AACD,YAAIU,gBAAgB,IAAIA,gBAAgB,KAAKF,oBAA7C,EAAmE;AACjE,gBAAMvB,MAAM,GAAG,CAAC,GAAGgB,KAAK,CAAChB,MAAV,CAAf;AACAA,UAAAA,MAAM,CAACgB,KAAK,CAACtB,KAAP,CAAN,GAAsB+B,gBAAtB;AACA,iBAAOrC,YAAY,CAACC,MAAD,EAASC,SAAT,oBACd0B,KADc;AAEjBhB,YAAAA;AAFiB,aAAnB;AAID;AACF,OAjFmC,CAmFpC;AACA;;;AACA,YAAM0B,cAAc,GAClBrC,MAAM,CAACF,GAAP,IAAc,IAAd,IAAsBE,MAAM,CAACF,GAAP,KAAeoC,oBAAoB,CAACpC,GAD5D;;AAEA,UAAIE,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACoB,IAAtC,EAA4C;AAC1C,YAAIsB,cAAc,IAAIlE,YAAY,KAAK,cAAvC,EAAuD;AACrDyD,UAAAA,gBAAgB,GAAGtD,iBAAnB;AACD,SAFD,MAEO,IAAI+D,cAAc,IAAIlE,YAAY,KAAK,OAAvC,EAAgD;AACrDyD,UAAAA,gBAAgB,GAAGU,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYX,gBAAgB,GAAG,CAA/B,CAAnB;AACD,SAFM,CAGP;AACA;AAJO,aAKF,IACHS,cAAc,IACdlE,YAAY,KAAK,SADjB,IAEAwD,KAAK,CAACpB,eAAN,CAAsBiC,MAAtB,GAA+B,CAH5B,EAIH;AACA,kBAAMC,QAAQ,GACZd,KAAK,CAACpB,eAAN,CAAsBoB,KAAK,CAACpB,eAAN,CAAsBiC,MAAtB,GAA+B,CAArD,CADF;AAEAZ,YAAAA,gBAAgB,GAAG/D,KAAK,CAACU,OAAN,CAAckE,QAAd,CAAnB;AACD;AACF;;AAED,UAAIC,WAAW,GAAG,KAAlB;;AACA,UAAI1C,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACc,QAAtC,EAAgD;AAC9CiC,QAAAA,WAAW,GAAG,CAAC,CAAC7E,KAAK,CAAC8E,IAAN,CAAW,CAACC,OAAD,EAAUX,CAAV,KAAgB;AACzC,cAAIW,OAAO,KAAK5C,MAAM,CAAClB,SAAvB,EAAkC;AAChC8C,YAAAA,gBAAgB,GAAGK,CAAnB;AACA,mBAAO,IAAP;AACD;;AACD,iBAAO,KAAP;AACD,SANe,CAAhB;;AAOA,YAAIS,WAAJ,EAAiB;AACf,gBAAMG,UAAU,GAAGlB,KAAK,CAAChB,MAAN,CAAaiB,gBAAb,CAAnB;AACA,gBAAMnC,WAAW,GAAGb,YAAY,CAACoB,MAAM,CAAClB,SAAR,CAAhC;AACA,cAAIgE,aAAa,GAAGD,UAApB;;AAEA,cAAI7C,MAAM,CAACA,MAAP,IAAiBP,WAArB,EAAkC;AAChC,kBAAMsD,gBAAgB,GAAGtD,WAAW,CAACI,iBAAZ,CACvBG,MAAM,CAACA,MADgB,EAEvB6C,UAFuB,CAAzB;;AAIA,gBAAIE,gBAAJ,EAAsB;AACpBD,cAAAA,aAAa,GAAGC,gBAAhB;AACD;AACF;;AAED,cAAI/C,MAAM,CAACd,MAAX,EAAmB;AACjB4D,YAAAA,aAAa,qBACRA,aADQ;AAEX5D,cAAAA,MAAM,oBACA4D,aAAa,CAAC5D,MAAd,IAAwB,EADxB,MAEDc,MAAM,CAACd,MAFN;AAFK,cAAb;AAOD;;AAED,cAAI4D,aAAa,KAAKD,UAAtB,EAAkC;AAChC,kBAAMlC,MAAM,GAAG,CAAC,GAAGgB,KAAK,CAAChB,MAAV,CAAf;AACAA,YAAAA,MAAM,CAACiB,gBAAD,CAAN,GAA2BkB,aAA3B;;AACA,kBAAM1C,SAAS,qBACVuB,KADU;AAEbhB,cAAAA,MAFa;AAGbN,cAAAA,KAAK,EAAEuB;AAHM,cAAf;;AAKA,mBAAO7B,YAAY,CAACC,MAAD,EAASC,SAAT,EAAoBG,SAApB,CAAnB;AACD,WATD,MASO,IACL0C,aAAa,KAAKD,UAAlB,IACAlB,KAAK,CAACtB,KAAN,KAAgBuB,gBADhB,IAEA3B,SAHK,EAIL;AACA,mBAAO,IAAP;AACD;AACF;AACF;;AAED,UAAID,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACqD,UAAtC,EAAkD;AAChD,cAAMlD,GAAG,GAAGE,MAAM,CAACF,GAAnB;AACA,cAAMmD,SAAS,GAAGtB,KAAK,CAAChB,MAAN,CAAagC,IAAb,CAAkBnB,KAAK,IAAIA,KAAK,CAAC1B,GAAN,KAAcA,GAAzC,CAAlB;;AACA,YAAImD,SAAJ,EAAe;AACb,gBAAM/D,MAAM,qBACP+D,SAAS,CAAC/D,MADH,MAEPc,MAAM,CAACd,MAFA,CAAZ;;AAIA,gBAAMyB,MAAM,GAAG,CAAC,GAAGgB,KAAK,CAAChB,MAAV,CAAf;AACAA,UAAAA,MAAM,CAACgB,KAAK,CAAChB,MAAN,CAAapC,OAAb,CAAqB0E,SAArB,CAAD,CAAN,qBACKA,SADL;AAEE/D,YAAAA;AAFF;AAIA,iBAAOa,YAAY,CAACC,MAAD,EAASC,SAAT,oBACd0B,KADc;AAEjBhB,YAAAA;AAFiB,aAAnB;AAID;AACF;;AAED,UAAIiB,gBAAgB,KAAKD,KAAK,CAACtB,KAA/B,EAAsC;AACpC,eAAON,YAAY,CAACC,MAAD,EAASC,SAAT,oBACd0B,KADc;AAEjBtB,UAAAA,KAAK,EAAEuB;AAFU,WAAnB;AAID,OALD,MAKO,IAAIc,WAAW,IAAI,CAAChB,UAApB,EAAgC;AACrC,eAAOC,KAAP;AACD,OAFM,MAEA,IAAIe,WAAJ,EAAiB;AACtB,iCAAYf,KAAZ;AACD;;AAED,YAAMuB,iBAAiB,GACrBlD,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACoB,IAAlC,IACAf,MAAM,CAACQ,IAAP,KAAgB2C,YAAY,CAACC,GAD7B,IAEApD,MAAM,CAACQ,IAAP,KAAgB2C,YAAY,CAACE,UAH/B;AAIA,YAAMC,4BAA4B,GAChC,CAACJ,iBAAD,IACClD,MAAM,CAACQ,IAAP,KAAgBb,iBAAiB,CAACoB,IAAlC,IAA0Cf,MAAM,CAACF,GAAP,IAAc,IAF3D,CAlMoC,CAsMpC;AACA;AACA;;AACA,UAAIwD,4BAAJ,EAAkC;AAChC,YAAIjD,KAAK,GAAGsB,KAAK,CAACtB,KAAlB;AACA,YAAIM,MAAM,GAAGgB,KAAK,CAAChB,MAAnB;AACA9C,QAAAA,KAAK,CAAC8E,IAAN,CAAW,CAACC,OAAD,EAAUX,CAAV,KAAgB;AACzB,gBAAMxC,WAAW,GAAGb,YAAY,CAACgE,OAAD,CAAhC;;AACA,cAAIX,CAAC,KAAK5B,KAAV,EAAiB;AACf,mBAAO,KAAP;AACD;;AACD,cAAIwC,UAAU,GAAGlC,MAAM,CAACsB,CAAD,CAAvB;;AACA,cAAIxC,WAAJ,EAAiB;AACfoD,YAAAA,UAAU,GAAGpD,WAAW,CAACI,iBAAZ,CAA8BG,MAA9B,EAAsC6C,UAAtC,CAAb;AACD;;AACD,cAAI,CAACA,UAAL,EAAiB;AACfxC,YAAAA,KAAK,GAAG4B,CAAR;AACA,mBAAO,IAAP;AACD;;AACD,cAAIY,UAAU,KAAKlC,MAAM,CAACsB,CAAD,CAAzB,EAA8B;AAC5BtB,YAAAA,MAAM,GAAG,CAAC,GAAGA,MAAJ,CAAT;AACAA,YAAAA,MAAM,CAACsB,CAAD,CAAN,GAAYY,UAAZ;AACAxC,YAAAA,KAAK,GAAG4B,CAAR;AACA,mBAAO,IAAP;AACD;;AACD,iBAAO,KAAP;AACD,SApBD,EAHgC,CAyBhC;AACA;;AACA,YAAIjC,MAAM,CAACuD,aAAX,EAA0B;AACxBlD,UAAAA,KAAK,GAAGsB,KAAK,CAACtB,KAAd;AACD;;AAED,YAAIA,KAAK,KAAKsB,KAAK,CAACtB,KAAhB,IAAyBM,MAAM,KAAKgB,KAAK,CAAChB,MAA9C,EAAsD;AACpD,iBAAOZ,YAAY,CAACC,MAAD,EAASC,SAAT,oBACd0B,KADc;AAEjBtB,YAAAA,KAFiB;AAGjBM,YAAAA;AAHiB,aAAnB;AAKD;AACF;;AAED,aAAOgB,KAAP;AACD,KAzPI;;AA2PL6B,IAAAA,oBAAoB,CAAC7B,KAAD,EAAQ;AAC1B,YAAM7C,SAAS,GAAG6C,KAAK,CAAChB,MAAN,CAAagB,KAAK,CAACtB,KAAnB,EAA0BvB,SAA5C;AACA,8BACEA,SADF,gDAEyC6C,KAAK,CAACtB,KAF/C;AAKA,YAAMZ,WAAW,GAAGb,YAAY,CAACE,SAAD,CAAhC;;AACA,UAAIW,WAAJ,EAAiB;AACf,eAAOA,WAAW,CAAC+D,oBAAZ,CAAiC7B,KAAK,CAAChB,MAAN,CAAagB,KAAK,CAACtB,KAAnB,CAAjC,CAAP;AACD;;AACD,aAAO,oCAAsB1C,YAAtB,EAAoCmB,SAApC,CAAP;AACD,KAvQI;;AAyQL2E,IAAAA,wBAAwB,CAAC3E,SAAD,EAAY;AAClC,aAAO,oCAAsBnB,YAAtB,EAAoCmB,SAApC,CAAP;AACD,KA3QI;;AA6QL4E,IAAAA,wBAAwB,CAAC/B,KAAD,EAAQ;AAC9B,YAAMH,KAAK,GAAGG,KAAK,CAAChB,MAAN,CAAagB,KAAK,CAACtB,KAAnB,CAAd;AACA,aAAOjB,wBAAwB,CAACoC,KAAD,CAA/B;AACD,KAhRI;;AAkRLnC,IAAAA,yBAAyB,CAACsE,IAAD,EAAOzE,MAAP,EAAe;AACtC,aAAOG,yBAAyB,CAACsE,IAAD,EAAOzE,MAAP,CAAhC;AACD,KApRI;;AAsRL0E,IAAAA,gBAAgB,EAAE,iCAChBjG,YADgB,EAEhBC,MAAM,CAACiG,wBAFS;AAtRb,GAAP;AA2RD,C","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (\n        backBehavior !== 'history' ||\n        (prevState && nextState && nextState.index === prevState.index)\n      ) {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      possibleNextState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n      isTransitioning: false,\n    };\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      if (\n        action.type === SwitchActions.JUMP_TO &&\n        (action.key == null || action.key === state.key)\n      ) {\n        const { params } = action;\n        const index = state.routes.findIndex(\n          route => route.routeName === action.routeName\n        );\n\n        if (index === -1) {\n          throw new Error(\n            `There is no route named '${action.routeName}' in the navigator with the key '${action.key}'.\\n` +\n              `Must be one of: ${state.routes\n                .map(route => `'${route.routeName}'`)\n                .join(',')}`\n          );\n        }\n\n        return getNextState(action, prevState, {\n          ...state,\n          routes: params\n            ? state.routes.map((route, i) =>\n                i === index\n                  ? {\n                      ...route,\n                      params: {\n                        ...route.params,\n                        ...params,\n                      },\n                    }\n                  : route\n              )\n            : state.routes,\n          index,\n        });\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      const isActionBackOrPop =\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP ||\n        action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren =\n        !isActionBackOrPop ||\n        (action.type === NavigationActions.BACK && action.key != null);\n\n      // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n          if (i === index) {\n            return false;\n          }\n          let childState = routes[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            index = i;\n            return true;\n          }\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n          return false;\n        });\n\n        // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, {\n            ...state,\n            index,\n            routes,\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"]}